## Agenda

1. whoami
1. Cassandra Current State
1. Connection Options
1. Java Native Driver
1. State of Astyanax
1. Grails Options


~~~~
## whoami

Jeff Beck

beckje01 on GitHub and Twitter

TechLead at ReachLocal
~~~~
## Cassandra Today

  * DSE Latest Uses C* 1.2
  * C* is on 2.0
  * CQL3

~~
## Cassandra Common Setup

  * Astyanax
  * C* 1.2
  * Wide Column Design

~~~~
## Connection Options

  * Astyanax
  * Hector
  * CQL|Java (JDBC)
  * 4-5 less popular ones
~~
## Astyanax

Thrift based with varying compatibility. Also supports some CQL3 via Thrift.

See Astyanax [Cassandra Compatability](https://github.com/Netflix/astyanax/wiki/Cassandra-compatibility)

~~
## Hector

Not as popular anymore, allows for connection pooling etc. Based on Thrift.

~~
## CQL - JDBC Based Solutions

Avoid these currently are not cluster aware so a single node failure can cause problems. Or you have to follow the bad practice having a LB in front of the cluster.
~~
## 4-5 More Clients

There are a lot of other clients and ORMs built out around Java check out all them [here](http://www.datastax.com/download/clientdrivers).
~~~~
## Java Native Driver

Based around CQL3 and a new binary protocol. Supports node discovery, load balancing and failover. Encourages CQL3 based data design.
~~
## Java Native Driver

CQL prepared statements claim to be 10% faster than thrift, with the first release. You have to model you data more like a traditional DB. It is new and come in two flavors.

~~
## Java Native Driver 1.x

Currently a generally available client, [docs](http://www.datastax.com/documentation/developer/java-driver/1.0/index.html) are good to help get you started. You don't get all the great async work that has been done in 2.x

~~
## Java Native Driver 2.x

Many breaking changes for the upgrade and requires Cassandra 2.0 for full feature set many items such as result set paging will throw an exception if used against a 1.2 C*. Current state is RC2, it does have nice async support with futures.
~~~~
## State of Astyanax

Netflix announced that they will be updating Astyanax to support both the new binary protocol and thrift. [Read here](http://techblog.netflix.com/2013/12/astyanax-update.html). There is even a beta out of [Astyanax Over Java Driver](https://github.com/Netflix/astyanax/wiki/Astyanax-over-Java-Driver) very early.
~~~~
## Grails Options

1. Astyanax [Plugin](http://grails.org/plugin/cassandra-astyanax)
1. Cassandra ORM [Plugin](http://grails.org/plugin/cassandra-orm)
1. Java Native Driver + DAO
1. Cassandra GORM [WIP](https://github.com/beckje01/grails-data-mapping/tree/cassandraNative)
~~~~
## Astyanax Plugin

A simple plugin that helps set up a simple Astyanax connection. Currently on Astyanax 1.56.44 which means it needs C* 1.1 or 1.2, this is a great option if you choose to hedge and stay with Astyanax.
~~~~
## Cassandra ORM Plugin

Allow a GORM Like interaction with Cassandra and has it's "domain" objects separated into their own folder. Supports two kinds of indices C* native secondary index and an implicit index that the plugin maintains.
~~
## Cassandra ORM Plugin

Not all the data will be easily available via CQL, the indices maintained by the ORM plugin will need to be queried separately if you want to interact with the data directly. Schema will need to be generated by hand, it should be end up having a few column families for User you will end up with at least User, User_IDX, and User_CTR.
~~
## Cassandra ORM Example Schema

[View Full Source](https://github.com/bflorian/cassandra-astyanax/blob/4027cb6589ce85b6bad90a8d0d3a917a39a66e48/test/data/schema.txt)

  create column family User
      with comparator=UTF8Type
      and column_metadata=[
          {column_name: id, validation_class: UTF8Type},
          {column_name: city, validation_class: UTF8Type, index_type: KEYS},
          {column_name: state, validation_class: UTF8Type, index_type: KEYS},
          {column_name: zip, validation_class: UTF8Type, index_type: KEYS},
          {column_name: e164phone, validation_class: UTF8Type, index_type: KEYS}
      ];

  create column family User_CTR
      with comparator = UTF8Type
      and default_validation_class = CounterColumnType;

~~~~
## Java Native Driver + DAO

Now that there is a simple native driver to use you can roll your own DAO layer that uses C*

This option feels very easy but not the best fit for Grails. It may be a better option for something lacking GORM.
~~~~
## Cassandra GORM

The GORM support for Cassandra was started a long time ago, based on Hector and very early but it has been in the Grails Data Mapping project for a while. I have resurrected it.
~~
## Cassandra GORM - Today

Currently I have the grails data mapping test compatibility kit running as I slowly implement features of GORM. Base persistence is working but not the query syntax yet.
~~
## C* GORM - Request for Comment

  * ID is going to be java.util.UUID
  * Types not supported by the Java Native Driver will be converted serialized to a ByteBuffer
  * Maps, Sets, Lists will be using the built in data types


